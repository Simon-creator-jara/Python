# -*- coding: utf-8 -*-
"""Complejidad_Algorítmica.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MjlDU-Q6RcqCYQM0-JdEF9nRbs9PnAXW
"""

import time

def factorial(n):
  respuesta=1
  while n>1:
    respuesta*=n
    n-=1
  return respuesta

def factorial_r(n):
  if n==1:
    return 1
  return n*factorial_r(n-1)

n=10

comienzo=time.time()
print(factorial(n))
final=time.time()
print(final-comienzo)

comienzo1=time.time()
print(factorial_r(n))
final1=time.time()
print(final1-comienzo1)

"""# Notación asintótico o Big O"""

#O(n) + O(n) = O(n+n) = O(2n) = O(n) //Crecimiento lineal
def f(n)
    for i in range(n):
        print(i)

    for i in range(n):
        print(i)

#O(n) + O(n*n) = O(n+n) = O(n + n^2) = O(n^2) //Crecimiento exponencial
def f(n)
    for i in range(n):
        print(i)

    for i in range(n * n):
        print(i)

#O(n) O(n) = O(nn) = O(n^2) //Crecimiento exponencial
def f(n)
    for i in range(n):
        for j in range(n):
            print(i,j)

#O(2**n) //tiene varias llamadas recursivas y eso hace al algoritmo con un crecimiento exponencial
def fibonacci(n):
    if n == 0 or n ==1:
      return 1

    return fibonacci(n - 1) + fibonacci(n - 2)

"""# Busqueda lineal

Busca en todos los elementos de manera secuencial
"""

def busqueda_lineal(lista,objetivo):
  match = False
  for elemento in lista:
    if elemento == objetivo:
      match = True

  return match

import random
tamano_de_lista=int(input("De que tamano será la lista?"))
objetivo = int(input("Que numero quieres encontrar?"))

lista = [random.randint(0,100) for i in range(tamano_de_lista)]
encontrado = busqueda_lineal(lista,objetivo)
print(lista)
print(f'El elemento {objetivo} {"1esta" if encontrado else "no esta"} en la lista')

"""#Búsqueda binaria"""

def busqueda_binaria(lista,comienzo,final,objetivo):
  if comienzo>final:
    return False
  medio=(comienzo+final)//2

  if lista[medio]==objetivo:
    return True
  elif lista[medio]<objetivo:
    return busqueda_binaria(lista,medio+1,final,objetivo)
  else:
    return busqueda_binaria(lista,comienzo,medio-1,objetivo)

import random
tamano_de_lista=int(input("De que tamano será la lista?"))
objetivo = int(input("Que numero quieres encontrar?"))

lista = sorted([random.randint(0,100) for i in range(tamano_de_lista)])
encontrado = busqueda_binaria(lista,0,len(lista),objetivo)
print(lista)
print(f'El elemento {objetivo} {"esta" if encontrado else "no esta"} en la lista')

"""# Ordenamiento burbuja"""

def ordenamiento_de_burbuja(lista):
  n=len(lista)
  for i in range(n):
    for j in range(0,n-i-1):
      if lista[j]>lista[j+1]:
        lista[j],lista[j+1]=lista[j+1],lista[j]
  return lista

import random
tamano_de_lista=int(input("De que tamano será la lista?"))

lista = sorted([random.randint(0,100) for i in range(tamano_de_lista)])
encontrado = ordenamiento_de_burbuja(lista)
print(lista)

"""# Ordenamiento por inserción"""

def ordenamiento_por_insercion(lista):

  for indice in range(1, len(lista)):
    valor_actual = lista[indice]
    posicion_actual = indice

    while posicion_actual > 0 and lista[posicion_actual - 1] > valor_actual:
        lista[posicion_actual] = lista[posicion_actual - 1]
        posicion_actual -= 1

    lista[posicion_actual] = valor_actual

  return lista

ordenamiento_por_insercion([50,5,6,9,1,0])

"""# Ordenamiento por mezcla"""

def ordenamiento_por_mezclas(lista):
  if len(lista)>1:
    medio=len(lista)//2
    izquierda=lista[:medio]
    derecha=lista[medio:]
    print(izquierda, '*'*5, derecha)

    #llamada recursiva en cada mitad
    ordenamiento_por_mezclas(izquierda)
    ordenamiento_por_mezclas(derecha)

    #Iteradores para recorrer las dos sublistas
    i = 0
    j = 0
    #Iterador para la lista principal
    k = 0

    while i < len(izquierda) and j < len(derecha):
      if izquierda[i] < derecha[j]:
        lista[k] = izquierda[i]
        i+=1
      else:
        lista[k] = derecha[j]
        j+=1

      k+=1

    while i < len(izquierda):
      lista[k]=izquierda[i]
      i +=1
      k +=1

    while j < len(derecha):
      lista[k] = derecha[j]
      j +=1
      k +=1

    print(f"izquierda {izquierda}, derecha {derecha}")
    print(lista)
    print('-' * 50)

  return lista

ordenamiento_por_mezclas([50,5,6,9,1,0])

"""# Graficando"""

from bokeh.plotting import figure,output_file,show

output_file('graficado_simple.html')
fig = figure()

total_vals=int(input('Cuantos valores quieres graficar?'))
x_vals = list(range(total_vals))
y_vals = []
for i in x_vals:
  val = int(input(f"Valor y para {i}"))
  y_vals.append(val)

fig.line(x_vals,y_vals, line_width=2)
show(fig)

"""# Optimización"""

def morral(tamano_morral,pesos,valores,n):
  if n ==0 or tamano_morral==0:
    return 0

  if pesos[n-1]>tamano_morral:
    return morral(tamano_morral,pesos,valores,n-1)


  return max(valores[n-1] + morral(tamano_morral-pesos[n-1],pesos,valores,n-1),
             morral(tamano_morral,pesos,valores,n-1))

valores=[60,100,120]
pesos=[10,20,30]
tamano_morral=25
n=len(valores)
resultado = morral(tamano_morral,pesos,valores,n)
print(resultado)