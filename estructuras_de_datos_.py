# -*- coding: utf-8 -*-
"""Estructuras de datos .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qV6PAfMDiIyry7HSpOSCGdXePRmEeGSi
"""

fruits=[]
fruits.append('Kiwi')
fruits.append('Berry')
fruits.append('Melon')

fruits
fruits.pop()

fruits.insert(0,'Apple')

fruits.insert(1,'Strawberry')

def pyramid_sum(lower,upper,margin=0):
  blanks="|"*margin
  print(blanks,lower,upper)
  if lower>upper:
    print(blanks,0)
    return 0
  else:

    result=lower+pyramid_sum(lower+1,upper,margin+4)
    print(blanks,result)
    return result

pyramid_sum(1,4)

def factorial(n):
  if n==1:
    return 1
  else:

    return n*factorial(n-1)
    print(n)

factorial(3)

def fibonacci(n):
  if n==0 or n==1:
    return 1
  return fibonacci(n-1)+fibonacci(n-2)

fibonacci(6)

"""# Array"""

class Array:
  def __init__(self,capacity,fill_value=None):
    self.items=list()
    for i in range(capacity):
      self.items.append(fill_value)

  def __len__(self):
    return len(self.items)

  def __str__(self):
    return str(self.items)

  def __iter__(self):
    return iter(self.items)

  def __getitem__(self,index):
    return self.items[index]

  def __setitem__(self,index,new_item):
    self.items[index]=new_item

a1=Array(5,2)

a1.__len__()

a1.__str__()

a1.__iter__()

a1.__getitem__(0)

##Array de dos dimensiones

class Grid():
  def __init__(self, rows, columns,fill_value=None):
    self.data=Array(rows)
    for row in range(rows):
      self.data[row]=Array(columns,fill_value)

  def get_height(self):
    return len(self.data)

  def get_width(self):
    return len(self.data[0])

  def __getitem__(self,index):
    return self.data[index]

  def __str__(self):
    result =""
    for row in range(self.get_height()):
      for col in range(self.get_width()):
        result+=str(self.data[row][col]) + " "
      result +="\n"

    return str(result)

g1=Grid(3,3)

print(g1)

for row in range(g1.get_height()):
  for column in range(g1.get_width()):
    g1[row][column]=row*column

g1.get_height()

"""# Nodos y singly linked list

- Datos repartidos en la memoria
- Se refiere por los nodos
"""

class Node():
  def __init__(self,data,next=None):
    self.data=data
    self.next=next

class TwoWayNode(Node):
  def __init__(self,data,previous=None,next=None):
    Node.__init__(self,data,next)
    self.previous=previous

head=TwoWayNode(1)
tail=head
for data in range(2,6):
  tail.next=TwoWayNode(data,tail)
  tail=tail.next
  print(tail.data)

probe=tail
while probe!=None:
  print(probe.data)
  probe=probe.previous

index=1
new_item="ham"
head=Node(None,None)
head.next=head
probe=head

probe.next=Node(new_item,probe.next)

print(probe.next.data)

n1=Node(None)
n2=Node("A",None)
n3=Node("B",n2)

n1=Node("C",n3)

head=None
for count in range(1,5):
  head=Node(count,head)

while head!=None:
  print(head.data)
  head=head.next

"""# Linked List"""

class SinglyLinkedList:
  def __init__(self):
    self.tail=None
    self.size=0

  def append(self,data):
    node = Node(data)

    if self.tail==None:
      self.tail=node
    else:
      current=self.tail
      while current.next:
        current=current.next

      current.next=node
    self.size+=1

  def size(self):
    return str(self.size)

  def iter(self):
    current = self.tail

    while current:
      val=current.data
      current=current.next
      yield val

  def delete(self,data):
    current = self.tail
    previous=self.tail

    while current:
      if current.data ==data:
        if current==self.tail:
          self.tail=current.next
        else:
          previous.next=current.next
          self.size-=1
          return current.data

      previous = current
      current = current.next

  def search(self,data):
    for node in self.iter():
      if data==node:
        print(f"Data {data} found!")

  def clear(self):
    self.tail=None
    self.head=None
    self.size=0

words = SinglyLinkedList()
words.append("egg")
words.append("ham")
words.append("spam")
current = words.tail

while current:
  print(current.data)
  current = current.next

for word in words.iter():
  print(word)

words.search('spam')

"""# Stack"""

class Stack:
  def __init__(self):
    self.top=None
    self.size=0

  def push(self,data):
    node = Node(data)

    if self.top:
      node.next=self.top
      self.top=node
    else:
      self.top=node

    self.size+=1

  def pop(self):
    if self.top:
      data = self.top.data
      self.size-=1

      if self.top.next:
        self.top=self.top.next
      else:
        self.top=None

      return data
    else:
      return "The stack is empty"

  def peak(self):
    if self.top:
      return self.top.data
    else:
      return "The stack is empty"

  def clear(self):
    while self.top:
      self.pop()

food = Stack()
food.push("egg")
food.push("ham")
food.push("spam")
food.pop()

"""# Queues"""

class ListQueue:
  def __init__(self):
    self.items=[]
    self.size=0

  def enqueue(self,data):
    self.items.insert(0,data)
    self.size+=1

  def dequeue(self):
    data = self.items.pop()
    self.size-=1
    return data

  def traverse(self):
    total_items = self.size

    for item in range(total_items):
      print(self.items[item])

food =ListQueue()

food.enqueue("eggs")
food.enqueue("ham")
food.enqueue("sham")

food.dequeue()

food.traverse()

"""# Stack based queue"""

class Queue:
  def __init__(self):
    self.inbound_stack=[]
    self.outbound_stack=[]

  def enqueue(self,data):
    self.inbound_stack.append(data)

  def dequeue(self):
    if not self.outbound_stack:
      while self.inbound_stack:
        self.outbound_stack.append(self.inbound_stack.pop())

    return self.outbound_stack.pop()

numbers=Queue()
numbers.enqueue(5)
numbers.enqueue(6)
numbers.enqueue(7)
print(numbers.inbound_stack)

"""# Queues basados en nodos"""

from pickle import NONE
class Queue:
  def __init__(self):
    self.head=None
    self.tail=None
    self.count=0

  def enqueue(self,data):
    new_node=TwoWayNode(data,None,None)
    if self.head is None:
      self.head=new_node
      self.tail=self.head
    else:
      new_node.previous=self.tail
      self.tail.next=new_node
      self.tail=new_node

    self.count+=1

  def dequeue(self):
    current=self.head
    if self.count ==1:
      self.count-=1
      self.head=None
      self.tail=None
    elif self.count >1:
      self.head=self.head.next
      self.head.previous = None
      self.count -=1

    return current.data

food = Queue()
food.enqueue("eggs")
food.enqueue("ham")
food.enqueue("spam")
food.head.data

food.head.next.data

food.tail.data

food.tail.previous.data

food.dequeue()

"""# Enumeración exhaustiva"""

objetivo = int(input("Escoge un entero: "))
respuesta=0
while respuesta**2 < objetivo:
  respuesta+=1

if respuesta**2 == objetivo:
  print(f"La raiz cuadrado de {objetivo} es {respuesta}")
else:
  print(f"{objetivo} no tiene una raíz cuadrada exacta")

"""# Aproximación de soluciones

"""

objetivo = int(input("Escoge un núemro: "))
epsilon = 0.01
paso= epsilon**2
respuesta=0.0

while abs(respuesta**2-objetivo)>=epsilon and respuesta <=objetivo:
  respuesta+=paso

if abs(respuesta**2 - objetivo)>=epsilon:
  print(f"No se encontro la ra´z cuadrada del on¿bjetivo")
else:
  print(f"La raíz cuadrada de {objetivo} es {respuesta}")

"""# Busqueda binaria"""

objetivo=int(input("Escoge un número: "))
epsilon=0.01
bajo=0.0
alto=max(1.0,objetivo)
respuesta=(alto+bajo)/2

while abs(respuesta**2 - objetivo)>=epsilon:
  if respuesta**2<objetivo:
    bajo=respuesta
  else:
    alto=respuesta

  respuesta=(alto+bajo)/2

print(f"La raiz cuadrada del objetivo es {respuesta}")

"""# Funciones
- Modularizar el código
- Dividir el código en pequeñas unidades lógicas

- Scope: Diferentes contextos de ejecución
"""